const { plcrash } = require('./compiled');

/**
 * CrashReport class
 */
class CrashReport {
  /**
   * Construct a CrashReport object.
   * @param {(Buffer | [number] | ArrayBuffer)} data Crash report data that is generated by PLCrashReport.
   */
  constructor(data) {
    if (data instanceof Buffer) {
      this.dataBuffer = data;
    } else if (data instanceof Array) {
      this.dataBuffer = Buffer.from(data);
    } else if (data instanceof ArrayBuffer) {
      this.dataBuffer = Buffer.from(new Uint8Array(data));
    }

    const crashReportHeaderLength = 8;
    let buffer = this.dataBuffer.slice(crashReportHeaderLength, this.dataBuffer.length);
    this.decoded = plcrash.CrashReport.decode(buffer);
  }

  /**
   * @returns {Buffer} Raw buffer of crash report.
   */
  rawBuffer() {
    return this.dataBuffer;
  }

  /**
   * @returns {object} Decoded crash report object with Protobuf.
   */
  decoded() {
    return this.decoded;
  }

  /**
   * @returns {object} Decoded crash report in JSON format.
   */
  toJSON() {
    let decodedJson = this.decoded.toJSON();

    for (let i = 0; i < decodedJson['binaryImages'].length; i ++) {
      let binaryDict = decodedJson['binaryImages'][i];
      let baseAddress = Number(binaryDict['baseAddress']);
      let size = Number(binaryDict['size']);
      let endAddress = baseAddress + size - 1;
      decodedJson['binaryImages'][i]['baseAddress'] = `0x${baseAddress.toString(16)}`;
      decodedJson['binaryImages'][i]['endAddress'] = `0x${endAddress.toString(16)}`;
    }

    return decodedJson;
  }

  /**
   * @returns {string} Decoded crash report in formatted string.
   */
  toString() {
    let decodedDict = this.toJSON();
    let decodedStr = 'Formatted Crash Report\n\n';
    for (let key of ['systemInfo', 'applicationInfo', 'processInfo', 'machineInfo', 'signal']) {
      for (let k in decodedDict[key]) {
        if (k === 'processor') {
          decodedStr += `${k.padEnd(40)}${decodedDict[key]['processor']['type']}\n`;
        } else {
          decodedStr += `${k.padEnd(40)}${decodedDict[key][k]}\n`;
        }
      }
    }

    decodedStr += '\n\n';

    for (let threadDict of decodedDict['threads']) {
      let tmp = `Thread ${threadDict['threadNumber']}\n\n`;

      if (threadDict['crashed'] === true) {
        tmp += 'Thread crashed with registers\n\n';
        for (let reg of threadDict['registers']) {
          tmp += `${reg['name']}: 0x${Number(reg['value']).toString(16).padStart(16, '0')}\n`;
        }
        tmp += '\n';
      }

      for (let idx = 0; idx < threadDict['frames'].length; idx++) {
        let fr = threadDict['frames'][idx];
        if ('pc' in fr) {
          let pc = Number(fr['pc']);
          if ('symbol' in fr) {
            let startAddress = Number(fr['symbol']['startAddress']);
            tmp += `${idx}\t\t0x${startAddress.toString(16)}\t${fr['symbol']['name']} + ${pc - startAddress}\n`;
          } else {
            tmp += `${idx}\t\t${pc.toString(16)}\n`;
          }
        }
      }

      decodedStr += `${tmp}\n\n`;
    }

    decodedStr += 'Binary Images\n\n';

    for (let binaryDict of decodedDict['binaryImages']) {
      let baseAddress = binaryDict['baseAddress'];
      let endAddress = binaryDict['endAddress'];
      let name = binaryDict['name'];
      let basename = name.split(/[\\/]/).pop();
      decodedStr += `${baseAddress} - ${endAddress}\t\t${basename}\t\t${name}\n`;
    }

    return decodedStr;
  }
}

module.exports = CrashReport;